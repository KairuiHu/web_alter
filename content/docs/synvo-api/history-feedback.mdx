---
id: session-history-feedback
title: History & Feedback Management
slug: /synvo-api/history-feedback
---

The Synvo API provides comprehensive conversation management capabilities, including history retrieval, session management, and feedback collection. Each conversation is identified by a unique session ID (SUID), and users can provide feedback on AI responses to help improve performance and track satisfaction.

## Authentication

All endpoints require authentication via:
- **API Key**: `X-API-Key: <api_key>`

## Base URL

```
https://api.synvo.ai
```

## History Management

### List Sessions

Returns a list of all conversation sessions for the authenticated user, including session summaries and creation dates.

**Endpoint:** `GET /history`

#### Example Request

<Tabs items={["cURL", "Python", "JavaScript"]}>
  <Tab value="cURL">

```bash
curl -X GET "https://api.synvo.ai/history" \
  -H "X-API-Key: ${API-KEY}"
```

  </Tab>
  <Tab value="Python">

```python
import requests

api_key = "<API_KEY>"
url = "https://api.synvo.ai/history"
headers = {"X-API-Key": api_key}

response = requests.get(url, headers=headers, timeout=30)
response.raise_for_status()
print(response.json())
```

  </Tab>
  <Tab value="JavaScript">

```javascript
const api_key = "<API_KEY>";

const response = await fetch("https://api.synvo.ai/history", {
  method: "GET",
  headers: {
    "X-API-Key": apiKey,
  },
});

if (!response.ok) {
  throw new Error(`Request failed: ${response.status}`);
}

console.log(await response.json());
```

  </Tab>
</Tabs>

#### Example Response

```json
{
  "success": true,
  "sessions": [
    {
      "suid": "sess_abc123xyz",
      "created_at": "2024-01-15T10:30:00Z",
      "summary": "Discussion about quarterly financial reports and revenue analysis"
    },
    {
      "suid": "sess_def456uvw",
      "created_at": "2024-01-14T15:45:00Z",
      "summary": "Technical documentation review and API integration questions"
    },
    {
      "suid": "sess_ghi789rst",
      "created_at": "2024-01-13T09:20:00Z",
      "summary": "Project planning and resource allocation discussion"
    }
  ]
}
```

### Get Session Details

Returns the complete message history for a specific conversation session, including all user and assistant messages.

**Endpoint:** `GET /history/{suid}`

#### Path Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `suid` | string | Yes | Session unique identifier |

#### Example Request

<Tabs items={["cURL", "Python", "JavaScript"]}>
  <Tab value="cURL">

```bash
curl -X GET "https://api.synvo.ai/history/sess_abc123xyz" \
  -H "X-API-Key: ${API-KEY}"
```

  </Tab>
  <Tab value="Python">

```python
import requests

api_key = "<API_KEY>"
suid = "sess_abc123xyz"
url = f"https://api.synvo.ai/history/{suid}"
headers = {"X-API-Key": api_key}

response = requests.get(url, headers=headers, timeout=30)
response.raise_for_status()
print(response.json())
```

  </Tab>
  <Tab value="JavaScript">

```javascript
const api_key = "<API_KEY>";
const suid = "sess_abc123xyz";

const response = await fetch(`https://api.synvo.ai/history/${suid}`, {
  method: "GET",
  headers: {
    "X-API-Key": apiKey,
  },
});

if (!response.ok) {
  throw new Error(`Request failed: ${response.status}`);
}

console.log(await response.json());
```

  </Tab>
</Tabs>

#### Example Response

```json
{
  "success": true,
  "session": {
    "suid": "sess_abc123xyz",
    "created_at": "2024-01-15T10:30:00Z",
    "summary": "Discussion about quarterly financial reports and revenue analysis",
    "messages": [
      {
        "role": "user",
        "content": [
          {
            "type": "text",
            "text": "Can you analyze the Q4 financial report I uploaded?"
          }
        ],
        "cuid": "msg_user123",
        "created_at": "2024-01-15T10:30:15Z"
      },
      {
        "role": "assistant",
        "content": [
          {
            "type": "text",
            "text": "I'll analyze your Q4 financial report. Let me examine the key metrics and trends..."
          }
        ],
        "cuid": "msg_asst456",
        "created_at": "2024-01-15T10:30:45Z",
        "searched_files": ["file_abc123xyz"]
      }
    ]
  }
}
```

#### Message Structure

| Field | Type | Description |
|-------|------|-------------|
| `role` | string | Message role: `user`, `assistant`, `system`, or `tool` |
| `content` | array | Message content items (text, files, etc.) |
| `cuid` | string | Conversation message unique identifier |
| `created_at` | string | Message timestamp |
| `searched_files` | array | File IDs that were searched (assistant messages only) |

### Delete Session

Permanently deletes a conversation session and all its messages. This action cannot be undone.

**Endpoint:** `DELETE /history/delete/{suid}`

#### Path Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `suid` | string | Yes | Session unique identifier |

#### Example Request

<Tabs items={["cURL", "Python", "JavaScript"]}>
  <Tab value="cURL">

```bash
curl -X DELETE "https://api.synvo.ai/history/delete/sess_abc123xyz" \
  -H "X-API-Key: ${API-KEY}"
```

  </Tab>
  <Tab value="Python">

```python
import requests

api_key = "<API_KEY>"
suid = "sess_abc123xyz"
url = f"https://api.synvo.ai/history/delete/{suid}"
headers = {"X-API-Key": api_key}

response = requests.delete(url, headers=headers, timeout=30)
response.raise_for_status()
print(response.json())
```

  </Tab>
  <Tab value="JavaScript">

```javascript
const api_key = "<API_KEY>";
const suid = "sess_abc123xyz";

const response = await fetch(`https://api.synvo.ai/history/delete/${suid}`, {
  method: "DELETE",
  headers: {
    "X-API-Key": apiKey,
  },
});

if (!response.ok) {
  throw new Error(`Request failed: ${response.status}`);
}

console.log(await response.json());
```

  </Tab>
</Tabs>

#### Example Response

```json
{
  "success": true,
  "message": "Session deleted successfully"
}
```

### Response Codes

- `200` - Request successful
- `401` - Unauthorized
- `404` - Session not found

## Feedback Management

The feedback system allows users to rate AI responses with like/dislike reactions, helping improve response quality and track satisfaction.

### Provide Feedback

Submit feedback for a specific assistant message in a conversation.

**Endpoint:** `POST /feedback`

#### Request Body

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `cuid` | string | Yes | Conversation message unique identifier |
| `feedback_type` | string | Yes | Type of feedback: `like` or `dislike` |

#### Example Request

<Tabs items={["cURL", "Python", "JavaScript"]}>
  <Tab value="cURL">

```bash
curl -X POST "https://api.synvo.ai/feedback" \
  -H "X-API-Key: ${API-KEY}" \
  -H "Content-Type: application/json" \
  -d '{
    "cuid": "msg_asst456",
    "feedback_type": "like"
  }'
```

  </Tab>
  <Tab value="Python">

```python
import requests

api_key = "<API_KEY>"
url = "https://api.synvo.ai/feedback"
headers = {
    "X-API-Key": api_key,
    "Content-Type": "application/json"
}
data = {
    "cuid": "msg_asst456",
    "feedback_type": "like"
}

response = requests.post(url, headers=headers, json=data, timeout=30)
response.raise_for_status()
print(response.json())
```

  </Tab>
  <Tab value="JavaScript">

```javascript
const api_key = "<API_KEY>";

const response = await fetch("https://api.synvo.ai/feedback", {
  method: "POST",
  headers: {
    "X-API-Key": apiKey,
    "Content-Type": "application/json"
  },
  body: JSON.stringify({
    cuid: "msg_asst456",
    feedback_type: "like"
  })
});

if (!response.ok) {
  throw new Error(`Request failed: ${response.status}`);
}

console.log(await response.json());
```

  </Tab>
</Tabs>

#### Example Response

```json
{
  "success": true,
  "feedback": {
    "cuid": "msg_asst456",
    "feedback_type": "like",
    "created_at": "2024-01-15T10:35:00Z",
    "updated_at": "2024-01-15T10:35:00Z"
  }
}
```

### Get Feedback

Retrieve feedback for a specific message.

**Endpoint:** `GET /feedback/{cuid}`

#### Path Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `cuid` | string | Yes | Conversation message unique identifier |

#### Example Request

<Tabs items={["cURL", "Python", "JavaScript"]}>
  <Tab value="cURL">

```bash
curl -X GET "https://api.synvo.ai/feedback/msg_asst456" \
  -H "X-API-Key: ${API-KEY}"
```

  </Tab>
  <Tab value="Python">

```python
import requests

api_key = "<API_KEY>"
cuid = "msg_asst456"
url = f"https://api.synvo.ai/feedback/{cuid}"
headers = {"X-API-Key": api_key}

response = requests.get(url, headers=headers, timeout=30)
response.raise_for_status()
print(response.json())
```

  </Tab>
  <Tab value="JavaScript">

```javascript
const api_key = "<API_KEY>";
const cuid = "msg_asst456";

const response = await fetch(`https://api.synvo.ai/feedback/${cuid}`, {
  method: "GET",
  headers: {
    "X-API-Key": apiKey,
  },
});

if (!response.ok) {
  throw new Error(`Request failed: ${response.status}`);
}

console.log(await response.json());
```

  </Tab>
</Tabs>

#### Example Response

```json
{
  "success": true,
  "feedback": {
    "cuid": "msg_asst456",
    "feedback_type": "like",
    "created_at": "2024-01-15T10:35:00Z",
    "updated_at": "2024-01-15T10:35:00Z"
  }
}
```

### Cancel Feedback

Remove previously provided feedback for a message.

**Endpoint:** `DELETE /feedback/{cuid}`

#### Path Parameters

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `cuid` | string | Yes | Conversation message unique identifier |

#### Example Request

<Tabs items={["cURL", "Python", "JavaScript"]}>
  <Tab value="cURL">

```bash
curl -X DELETE "https://api.synvo.ai/feedback/msg_asst456" \
  -H "X-API-Key: ${API-KEY}"
```

  </Tab>
  <Tab value="Python">

```python
import requests

api_key = "<API_KEY>"
cuid = "msg_asst456"
url = f"https://api.synvo.ai/feedback/{cuid}"
headers = {"X-API-Key": api_key}

response = requests.delete(url, headers=headers, timeout=30)
response.raise_for_status()
print(response.json())
```

  </Tab>
  <Tab value="JavaScript">

```javascript
const api_key = "<API_KEY>";
const cuid = "msg_asst456";

const response = await fetch(`https://api.synvo.ai/feedback/${cuid}`, {
  method: "DELETE",
  headers: {
    "X-API-Key": apiKey,
  },
});

if (!response.ok) {
  throw new Error(`Request failed: ${response.status}`);
}

console.log(await response.json());
```

  </Tab>
</Tabs>

#### Example Response

```json
{
  "success": true,
  "message": "Feedback removed successfully"
}
```

### Batch Retrieve Feedback

Get feedback for multiple messages in a single request.

**Endpoint:** `POST /feedback/batch`

#### Request Body

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `cuids` | array | Yes | Array of conversation message unique identifiers |

#### Example Request

<Tabs items={["cURL", "Python", "JavaScript"]}>
  <Tab value="cURL">

```bash
curl -X POST "https://api.synvo.ai/feedback/batch" \
  -H "X-API-Key: ${API-KEY}" \
  -H "Content-Type: application/json" \
  -d '{
    "cuids": ["msg_asst456", "msg_asst789", "msg_asst012"]
  }'
```

  </Tab>
  <Tab value="Python">

```python
import requests

api_key = "<API_KEY>"
url = "https://api.synvo.ai/feedback/batch"
headers = {
    "X-API-Key": api_key,
    "Content-Type": "application/json"
}
data = {
    "cuids": ["msg_asst456", "msg_asst789", "msg_asst012"]
}

response = requests.post(url, headers=headers, json=data, timeout=30)
response.raise_for_status()
print(response.json())
```

  </Tab>
  <Tab value="JavaScript">

```javascript
const api_key = "<API_KEY>";

const response = await fetch("https://api.synvo.ai/feedback/batch", {
  method: "POST",
  headers: {
    "X-API-Key": apiKey,
    "Content-Type": "application/json"
  },
  body: JSON.stringify({
    cuids: ["msg_asst456", "msg_asst789", "msg_asst012"]
  })
});

if (!response.ok) {
  throw new Error(`Request failed: ${response.status}`);
}

console.log(await response.json());
```

  </Tab>
</Tabs>

#### Example Response

```json
{
  "success": true,
  "feedback": {
    "msg_asst456": {
      "feedback_type": "like",
      "created_at": "2024-01-15T10:35:00Z",
      "updated_at": "2024-01-15T10:35:00Z"
    },
    "msg_asst789": {
      "feedback_type": "dislike",
      "created_at": "2024-01-15T10:40:00Z",
      "updated_at": "2024-01-15T10:40:00Z"
    },
    "msg_asst012": null
  }
}
```

### Response Codes

- `200` - Request successful
- `201` - Feedback created successfully
- `400` - Invalid request (e.g., trying to provide feedback on non-assistant messages)
- `401` - Unauthorized
- `404` - Message not found

## Complete Implementation Examples

### History Manager Class

<Tabs items={["Python", "JavaScript"]}>
  <Tab value="Python">

```python
import requests
import time
from typing import Optional, List, Dict, Any

class HistoryManager:
    def __init__(self, api_key: str, base_url: str = "https://api.synvo.ai"):
        """Initialize History Manager with API credentials"""
        self.api_key = api_key
        self.base_url = base_url
        self.headers = {"X-API-Key": api_key}
    
    def list_sessions(self) -> List[Dict[str, Any]]:
        """Get all conversation sessions"""
        response = requests.get(f"{self.base_url}/history", headers=self.headers, timeout=30)
        response.raise_for_status()
        return response.json().get("sessions", [])
    
    def get_session(self, suid: str) -> Dict[str, Any]:
        """Get complete session details including messages"""
        response = requests.get(f"{self.base_url}/history/{suid}", headers=self.headers, timeout=30)
        response.raise_for_status()
        return response.json().get("session", {})
    
    def delete_session(self, suid: str) -> Dict[str, Any]:
        """Delete a conversation session"""
        response = requests.delete(f"{self.base_url}/history/delete/{suid}", headers=self.headers, timeout=30)
        response.raise_for_status()
        return response.json()
    
    def search_sessions(self, query: str) -> List[Dict[str, Any]]:
        """Search through session summaries"""
        sessions = self.list_sessions()
        query_lower = query.lower()
        return [s for s in sessions if query_lower in s.get("summary", "").lower()]
    
    def get_recent_sessions(self, limit: int = 10) -> List[Dict[str, Any]]:
        """Get most recent sessions"""
        sessions = self.list_sessions()
        # Sort by created_at descending
        sessions.sort(key=lambda x: x.get("created_at", ""), reverse=True)
        return sessions[:limit]
    
    def export_session(self, suid: str, format: str = "json") -> Any:
        """Export session in different formats"""
        session = self.get_session(suid)
        
        if format == "json":
            return session
        elif format == "text":
            # Convert to readable text format
            text_output = f"Session: {session['suid']}\n"
            text_output += f"Created: {session['created_at']}\n"
            text_output += f"Summary: {session.get('summary', 'N/A')}\n"
            text_output += "\nMessages:\n" + "="*50 + "\n"
            
            for msg in session.get("messages", []):
                text_output += f"\n[{msg['role'].upper()}] - {msg['created_at']}\n"
                for content in msg["content"]:
                    if content["type"] == "text":
                        text_output += f"{content['text']}\n"
                text_output += "-"*30 + "\n"
            
            return text_output
        else:
            raise ValueError(f"Unsupported format: {format}")

# Usage Example
if __name__ == "__main__":
    # Initialize manager
    api_key = "your_api_key_here"
    history_manager = HistoryManager(api_key)
    
    # Get all sessions
    sessions = history_manager.list_sessions()
    print(f"Found {len(sessions)} sessions")
    
    # Get recent sessions
    recent = history_manager.get_recent_sessions(5)
    for session in recent:
        print(f"Session {session['suid']}: {session['summary'][:50]}...")
    
    # Search sessions
    search_results = history_manager.search_sessions("financial")
    print(f"Found {len(search_results)} sessions matching 'financial'")
    
    # Export a session
    if sessions:
        first_session_id = sessions[0]["suid"]
        
        # Export as JSON
        json_export = history_manager.export_session(first_session_id, "json")
        
        # Export as text
        text_export = history_manager.export_session(first_session_id, "text")
        print(text_export[:500])  # Print first 500 chars
```

  </Tab>
  <Tab value="JavaScript">

```javascript
class HistoryManager {
  constructor(apiKey, baseUrl = "https://api.synvo.ai") {
    this.apiKey = apiKey;
    this.baseUrl = baseUrl;
    this.headers = { "X-API-Key": apiKey };
  }
  
  async listSessions() {
    const response = await fetch(`${this.baseUrl}/history`, {
      method: "GET",
      headers: this.headers
    });
    
    if (!response.ok) {
      throw new Error(`Request failed: ${response.status}`);
    }
    
    const data = await response.json();
    return data.sessions || [];
  }
  
  async getSession(suid) {
    const response = await fetch(`${this.baseUrl}/history/${suid}`, {
      method: "GET",
      headers: this.headers
    });
    
    if (!response.ok) {
      throw new Error(`Request failed: ${response.status}`);
    }
    
    const data = await response.json();
    return data.session || {};
  }
  
  async deleteSession(suid) {
    const response = await fetch(`${this.baseUrl}/history/delete/${suid}`, {
      method: "DELETE",
      headers: this.headers
    });
    
    if (!response.ok) {
      throw new Error(`Request failed: ${response.status}`);
    }
    
    return await response.json();
  }
  
  async searchSessions(query) {
    const sessions = await this.listSessions();
    const queryLower = query.toLowerCase();
    return sessions.filter(s => 
      (s.summary || "").toLowerCase().includes(queryLower)
    );
  }
  
  async getRecentSessions(limit = 10) {
    const sessions = await this.listSessions();
    // Sort by created_at descending
    sessions.sort((a, b) => 
      new Date(b.created_at) - new Date(a.created_at)
    );
    return sessions.slice(0, limit);
  }
  
  async exportSession(suid, format = "json") {
    const session = await this.getSession(suid);
    
    if (format === "json") {
      return session;
    } else if (format === "text") {
      // Convert to readable text format
      let textOutput = `Session: ${session.suid}\n`;
      textOutput += `Created: ${session.created_at}\n`;
      textOutput += `Summary: ${session.summary || "N/A"}\n`;
      textOutput += "\nMessages:\n" + "=".repeat(50) + "\n";
      
      for (const msg of session.messages || []) {
        textOutput += `\n[${msg.role.toUpperCase()}] - ${msg.created_at}\n`;
        for (const content of msg.content) {
          if (content.type === "text") {
            textOutput += `${content.text}\n`;
          }
        }
        textOutput += "-".repeat(30) + "\n";
      }
      
      return textOutput;
    } else {
      throw new Error(`Unsupported format: ${format}`);
    }
  }
}

// Usage Example
async function main() {
  // Initialize manager
  const apiKey = "your_api_key_here";
  const historyManager = new HistoryManager(apiKey);
  
  try {
    // Get all sessions
    const sessions = await historyManager.listSessions();
    console.log(`Found ${sessions.length} sessions`);
    
    // Get recent sessions
    const recent = await historyManager.getRecentSessions(5);
    for (const session of recent) {
      console.log(`Session ${session.suid}: ${session.summary.substring(0, 50)}...`);
    }
    
    // Search sessions
    const searchResults = await historyManager.searchSessions("financial");
    console.log(`Found ${searchResults.length} sessions matching 'financial'`);
    
    // Export a session
    if (sessions.length > 0) {
      const firstSessionId = sessions[0].suid;
      
      // Export as JSON
      const jsonExport = await historyManager.exportSession(firstSessionId, "json");
      
      // Export as text
      const textExport = await historyManager.exportSession(firstSessionId, "text");
      console.log(textExport.substring(0, 500));  // Print first 500 chars
    }
  } catch (error) {
    console.error("Error:", error);
  }
}

// Run if this is the main module
if (require.main === module) {
  main();
}
```

  </Tab>
</Tabs>

### Feedback Manager Class

<Tabs items={["Python", "JavaScript"]}>
  <Tab value="Python">

```python
import requests
from typing import Optional, Dict, Any, List
from enum import Enum

class FeedbackType(Enum):
    LIKE = "like"
    DISLIKE = "dislike"
    NEUTRAL = "neutral"

class FeedbackManager:
    def __init__(self, api_key: str, base_url: str = "https://api.synvo.ai"):
        """Initialize Feedback Manager with API credentials"""
        self.api_key = api_key
        self.base_url = base_url
        self.headers = {
            "X-API-Key": api_key,
            "Content-Type": "application/json"
        }
    
    def provide_feedback(self, cuid: str, feedback_type: FeedbackType) -> Dict[str, Any]:
        """Provide feedback for a message"""
        data = {
            "cuid": cuid,
            "feedback_type": feedback_type.value
        }
        response = requests.post(
            f"{self.base_url}/feedback",
            headers=self.headers,
            json=data,
            timeout=30
        )
        response.raise_for_status()
        return response.json()
    
    def get_feedback(self, cuid: str) -> Optional[Dict[str, Any]]:
        """Get feedback for a specific message"""
        response = requests.get(
            f"{self.base_url}/feedback/{cuid}",
            headers={"X-API-Key": self.api_key},
            timeout=30
        )
        
        if response.status_code == 404:
            return None
        
        response.raise_for_status()
        return response.json().get("feedback")
    
    def cancel_feedback(self, cuid: str) -> Dict[str, Any]:
        """Cancel/remove feedback for a message"""
        response = requests.delete(
            f"{self.base_url}/feedback/{cuid}",
            headers={"X-API-Key": self.api_key},
            timeout=30
        )
        response.raise_for_status()
        return response.json()
    
    def batch_get_feedback(self, cuids: List[str]) -> Dict[str, Optional[Dict[str, Any]]]:
        """Get feedback for multiple messages"""
        data = {"cuids": cuids}
        response = requests.post(
            f"{self.base_url}/feedback/batch",
            headers=self.headers,
            json=data,
            timeout=30
        )
        response.raise_for_status()
        return response.json().get("feedback", {})
    
    def like_message(self, cuid: str) -> Dict[str, Any]:
        """Convenience method to like a message"""
        return self.provide_feedback(cuid, FeedbackType.LIKE)
    
    def dislike_message(self, cuid: str) -> Dict[str, Any]:
        """Convenience method to dislike a message"""
        return self.provide_feedback(cuid, FeedbackType.DISLIKE)
    
    def toggle_like(self, cuid: str) -> FeedbackType:
        """Toggle like status: none -> like -> none"""
        current = self.get_feedback(cuid)
        
        if current and current.get("feedback_type") == "like":
            # Currently liked, remove feedback
            self.cancel_feedback(cuid)
            return FeedbackType.NEUTRAL
        else:
            # Not liked (neutral or disliked), set to like
            self.like_message(cuid)
            return FeedbackType.LIKE
    
    def toggle_dislike(self, cuid: str) -> FeedbackType:
        """Toggle dislike status: none -> dislike -> none"""
        current = self.get_feedback(cuid)
        
        if current and current.get("feedback_type") == "dislike":
            # Currently disliked, remove feedback
            self.cancel_feedback(cuid)
            return FeedbackType.NEUTRAL
        else:
            # Not disliked (neutral or liked), set to dislike
            self.dislike_message(cuid)
            return FeedbackType.DISLIKE
    
    def get_session_feedback_summary(self, session: Dict[str, Any]) -> Dict[str, Any]:
        """Get feedback summary for all messages in a session"""
        assistant_messages = [
            msg for msg in session.get("messages", [])
            if msg["role"] == "assistant" and msg.get("cuid")
        ]
        
        if not assistant_messages:
            return {
                "total_messages": 0,
                "liked": 0,
                "disliked": 0,
                "no_feedback": 0,
                "satisfaction_rate": 0.0
            }
        
        cuids = [msg["cuid"] for msg in assistant_messages]
        feedback_data = self.batch_get_feedback(cuids)
        
        liked = sum(1 for f in feedback_data.values() 
                   if f and f.get("feedback_type") == "like")
        disliked = sum(1 for f in feedback_data.values() 
                      if f and f.get("feedback_type") == "dislike")
        no_feedback = sum(1 for f in feedback_data.values() if f is None)
        
        total = len(assistant_messages)
        satisfaction_rate = (liked / total * 100) if total > 0 else 0
        
        return {
            "total_messages": total,
            "liked": liked,
            "disliked": disliked,
            "no_feedback": no_feedback,
            "satisfaction_rate": round(satisfaction_rate, 2),
            "feedback_details": feedback_data
        }

# Usage Example
if __name__ == "__main__":
    # Initialize managers
    api_key = "your_api_key_here"
    feedback_manager = FeedbackManager(api_key)
    history_manager = HistoryManager(api_key)
    
    # Get a session
    sessions = history_manager.list_sessions()
    if sessions:
        session_id = sessions[0]["suid"]
        session = history_manager.get_session(session_id)
        
        # Get feedback summary for the session
        summary = feedback_manager.get_session_feedback_summary(session)
        print(f"Session Feedback Summary:")
        print(f"  Total Messages: {summary['total_messages']}")
        print(f"  Liked: {summary['liked']}")
        print(f"  Disliked: {summary['disliked']}")
        print(f"  No Feedback: {summary['no_feedback']}")
        print(f"  Satisfaction Rate: {summary['satisfaction_rate']}%")
        
        # Provide feedback for the first assistant message
        assistant_msgs = [m for m in session["messages"] 
                         if m["role"] == "assistant" and m.get("cuid")]
        
        if assistant_msgs:
            first_msg_id = assistant_msgs[0]["cuid"]
            
            # Like the message
            result = feedback_manager.like_message(first_msg_id)
            print(f"\nLiked message {first_msg_id}")
            
            # Toggle like (will remove the like)
            new_state = feedback_manager.toggle_like(first_msg_id)
            print(f"Toggled like, new state: {new_state.value}")
```

  </Tab>
  <Tab value="JavaScript">

```javascript
const FeedbackType = {
  LIKE: "like",
  DISLIKE: "dislike",
  NEUTRAL: "neutral"
};

class FeedbackManager {
  constructor(apiKey, baseUrl = "https://api.synvo.ai") {
    this.apiKey = apiKey;
    this.baseUrl = baseUrl;
    this.headers = {
      "X-API-Key": apiKey,
      "Content-Type": "application/json"
    };
  }
  
  async provideFeedback(cuid, feedbackType) {
    const response = await fetch(`${this.baseUrl}/feedback`, {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify({
        cuid: cuid,
        feedback_type: feedbackType
      })
    });
    
    if (!response.ok) {
      throw new Error(`Request failed: ${response.status}`);
    }
    
    return await response.json();
  }
  
  async getFeedback(cuid) {
    const response = await fetch(`${this.baseUrl}/feedback/${cuid}`, {
      method: "GET",
      headers: { "X-API-Key": this.apiKey }
    });
    
    if (response.status === 404) {
      return null;
    }
    
    if (!response.ok) {
      throw new Error(`Request failed: ${response.status}`);
    }
    
    const data = await response.json();
    return data.feedback;
  }
  
  async cancelFeedback(cuid) {
    const response = await fetch(`${this.baseUrl}/feedback/${cuid}`, {
      method: "DELETE",
      headers: { "X-API-Key": this.apiKey }
    });
    
    if (!response.ok) {
      throw new Error(`Request failed: ${response.status}`);
    }
    
    return await response.json();
  }
  
  async batchGetFeedback(cuids) {
    const response = await fetch(`${this.baseUrl}/feedback/batch`, {
      method: "POST",
      headers: this.headers,
      body: JSON.stringify({ cuids: cuids })
    });
    
    if (!response.ok) {
      throw new Error(`Request failed: ${response.status}`);
    }
    
    const data = await response.json();
    return data.feedback || {};
  }
  
  async likeMessage(cuid) {
    return await this.provideFeedback(cuid, FeedbackType.LIKE);
  }
  
  async dislikeMessage(cuid) {
    return await this.provideFeedback(cuid, FeedbackType.DISLIKE);
  }
  
  async toggleLike(cuid) {
    const current = await this.getFeedback(cuid);
    
    if (current && current.feedback_type === "like") {
      // Currently liked, remove feedback
      await this.cancelFeedback(cuid);
      return FeedbackType.NEUTRAL;
    } else {
      // Not liked (neutral or disliked), set to like
      await this.likeMessage(cuid);
      return FeedbackType.LIKE;
    }
  }
  
  async toggleDislike(cuid) {
    const current = await this.getFeedback(cuid);
    
    if (current && current.feedback_type === "dislike") {
      // Currently disliked, remove feedback
      await this.cancelFeedback(cuid);
      return FeedbackType.NEUTRAL;
    } else {
      // Not disliked (neutral or liked), set to dislike
      await this.dislikeMessage(cuid);
      return FeedbackType.DISLIKE;
    }
  }
  
  async getSessionFeedbackSummary(session) {
    const assistantMessages = (session.messages || []).filter(
      msg => msg.role === "assistant" && msg.cuid
    );
    
    if (assistantMessages.length === 0) {
      return {
        total_messages: 0,
        liked: 0,
        disliked: 0,
        no_feedback: 0,
        satisfaction_rate: 0.0
      };
    }
    
    const cuids = assistantMessages.map(msg => msg.cuid);
    const feedbackData = await this.batchGetFeedback(cuids);
    
    let liked = 0;
    let disliked = 0;
    let noFeedback = 0;
    
    for (const feedback of Object.values(feedbackData)) {
      if (!feedback) {
        noFeedback++;
      } else if (feedback.feedback_type === "like") {
        liked++;
      } else if (feedback.feedback_type === "dislike") {
        disliked++;
      }
    }
    
    const total = assistantMessages.length;
    const satisfactionRate = total > 0 ? (liked / total * 100) : 0;
    
    return {
      total_messages: total,
      liked: liked,
      disliked: disliked,
      no_feedback: noFeedback,
      satisfaction_rate: Math.round(satisfactionRate * 100) / 100,
      feedback_details: feedbackData
    };
  }
}

// Usage Example
async function main() {
  // Initialize managers
  const apiKey = "your_api_key_here";
  const feedbackManager = new FeedbackManager(apiKey);
  const historyManager = new HistoryManager(apiKey);
  
  try {
    // Get a session
    const sessions = await historyManager.listSessions();
    if (sessions.length > 0) {
      const sessionId = sessions[0].suid;
      const session = await historyManager.getSession(sessionId);
      
      // Get feedback summary for the session
      const summary = await feedbackManager.getSessionFeedbackSummary(session);
      console.log("Session Feedback Summary:");
      console.log(`  Total Messages: ${summary.total_messages}`);
      console.log(`  Liked: ${summary.liked}`);
      console.log(`  Disliked: ${summary.disliked}`);
      console.log(`  No Feedback: ${summary.no_feedback}`);
      console.log(`  Satisfaction Rate: ${summary.satisfaction_rate}%`);
      
      // Provide feedback for the first assistant message
      const assistantMsgs = session.messages.filter(
        m => m.role === "assistant" && m.cuid
      );
      
      if (assistantMsgs.length > 0) {
        const firstMsgId = assistantMsgs[0].cuid;
        
        // Like the message
        const result = await feedbackManager.likeMessage(firstMsgId);
        console.log(`\nLiked message ${firstMsgId}`);
        
        // Toggle like (will remove the like)
        const newState = await feedbackManager.toggleLike(firstMsgId);
        console.log(`Toggled like, new state: ${newState}`);
      }
    }
  } catch (error) {
    console.error("Error:", error);
  }
}

// Run if this is the main module
if (require.main === module) {
  main();
}
```

  </Tab>
</Tabs>
